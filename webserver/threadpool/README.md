## 半同步/半反应堆线程池
### 服务器的基本框架
* io处理单元:处理客户端的连接，读写网络数据
* 逻辑单元:处理业务逻辑的线程
* 网络存储单元:本地数据库和文件

### 五种网络io模型
* **阻塞IO**:必须等待调用函数返回才可以进行下一步，返回期间什么都不做只检测是否返回
* **非阻塞IO**:每隔一段时间就去检测io时间是否就绪，没有就绪就可以做其他事情，非阻塞io总是立即返回
* **信号驱动IO**:安装一个信号驱动函数，进程继续运行不阻塞，当IO事件就绪就发送信号，处理IO事件
* **IO复用**:select/poll函数实现IO复用两个函数进程也会阻塞，可以同时阻塞多个IO同时对多个读写操作IO进行检测
* **异步IO**:调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小，文件偏移及通知的方式，然后立即返回

### 事件处理模式
* **reactor**模式中，主线程只负责监听文件描述符上是否有事件发生，有的话；立即通知工作线程读写数据接受新连接的及处理客户请求都在工作线程完成
* **proactor**模式中，主线程和内核负责读写数据接受新连接io工作线程只负责业务逻辑，客户端的请求

### 并发编程模式
并发编程的实现方法由多进程和多线程两种，这里主要是指io处理单元和逻辑单元协同完成任务的方法
* 半同步/半异步模式
* 领导者/追随者模式

## 半同步/半反应堆
并发模式中的同步和异步
> * 同步是程序按照顺序执行
> * 异步是程序的执行由系统事件驱动

半同步/半异步模式工作流程
> * 同步线程用于处理客户逻辑
> * 异步线程用于处理I/O事件
> * 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
> * 请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象

半同步/半反应堆工作流程（以Proactor模式为例）
> * 主线程充当异步线程，负责监听所有socket上的事件
> * 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
> * 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
> * 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权