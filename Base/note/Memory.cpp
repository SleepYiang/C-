//形参默认值（给默认值从右向左给）
//调用效率的问题（在形参处给默认值少一次move可以提高效率）
//定义出可以给形参默认参数，声明处也可以给参数默认值
// 形参默认值只能出现一次


//inline函数（使用场景：当函数的调用大于函数执行本身的开销时）
//inline函数和普通函数的区别？

//在编译期过程中，就没有函数的调用开销了，在函数的调用点直接把函数的代码进行了展开处理
//inline函数不在生成相应的函数符号

//只是建议编译器处理成内联函数
//但是不是所有的inline函数都百衲衣器处理成内联函数（递归）

//inline在debug版本下不会出现，在release版本下才能出现



//***************************************函数重载

//1.为什么c++支持函数重载c语言不支持函数重载

//c++代码产生函数符号时，函数名+参数列表类型组成的
//C                   函数名来决定

//2.函数重载需要注意什么

//函数重载
//函数名相同，参数列表的个数和类型不同
//一组函数称的上重载，一定先是在同一个作用域中的
//const和volatile的时候，怎么影响形参类型的
//函数名相同参数列表相同返回值不同，不叫重载

//多态
//静态的多态：函数重载
//动态的多态

//3.c++和c语言如何相互调用
//把c函数的声明扩在extern中
//c调用c++ 把c++代码阔在extern“C”中
//extern"C"{函数代码}

//**************************************const相关
//const怎么理解， c和c++中const的区别
//const修饰的变量不能够在作为左值，初始化完成后，值不可以被修改
//c中的const修饰的量可以不初始化——————常变量（当成一个变量编译的）
//c++的cons必须初始化————————————常量（出现常量名字的地方都被常量替换）


//const 修饰的量   常量
//普通变量的区别是什么 1.编译方式不同了  2.不能在作为左值了

//const修饰的量常出现的错误是
//1.常量不可以在作为左值
//2.不能把常量的地址泄露给一个普通的指针或者普通的引用变量（可以间接修改常量的值）

//const和一级指针的结合
//const修饰的是离他最近的类型
//const int *p         //可以任意指向不同的int类型内存，但是不能通过指针间接修改指向内存的值
//int const *p

//int *const p         //p是常量不可以指向其他内存，但是可以通过指针解引用修改指向内存的值

//const int *const p

//const 和二级指针的结合
//const int **q  **q的值不可以改变
//int* const *q  *q的值不可以被改变
//int** const q   q的值不可以被改变

//总结const和指针类型转换公式：
//int* <=const int*是错误
//const int* <=int * 是可以的
//int** <=const int** 错误的
//const int** <=int ** 错误的
//const 右边如果没有指针* 的话，const是不参与类型的

//c++引用和指针的区别
//左值引用，右值引用

//左值；有内存 有名字 值可以修改
//右值； 没内存 没名字 （一个右值引用变量本身是一个左值）
//右值引用专门用来引用右值类型，指令上，可以自动产生临时变量，直接引用临时变量
//不能用一个右值引用来引用一个左值
//引用的实例

//引用是一种更安全的指针
//1.引用需要初始化，指针可以不初始化（定义一个引用和定义一个指针变量在汇编语言上他们都是相同的）
//2.引用只有一级引用没有多级引用
//3.通过指针修改内存的值和通过引用修改内存的值其底层的指令也是一样的

