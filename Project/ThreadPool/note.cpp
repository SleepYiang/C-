//并发和并行
    //单核：分时间片进行看着像同时进行,一个cpu处理多个任务（并发）
    //多核：多个任务在不同的核心上执行（并行）


//多线程的优势
  //多线程就一定好吗？   不一定 要看当前程序的类型来做判断

    //cpu密集型（多核的情况下也是适合多线程的）
    //程序中的指令主要适用于计算的，进行数据的分析，运算

    //io密集型（更加适合设计成多线程程序）
    //程序中的指令主要是设计一些io操作，比如设备网络操作（等待客户端的连接），文件操作      //IO操作可以把程序阻塞住
    //单核中 io操作适合多线程  cup密集想的操作并不适合多线程

    //线程的调度需要额外的花费， 将线程信息保存在线程栈中

    //线程的消耗
    //1.线程的创建和销毁都是非常重的操作（空间的切换 用户空间，内核空间）（执行业务创建线程，业务执行完毕，销毁线程）
    //2.线程栈本身就需要大量的内存
    //3.线程的上下文切换都需要时间（线程过多需要线程的切换）
    //4.大量的线程同时唤醒会使系统出现锯齿状负载或者瞬间负载很大导致的宕机（同时唤醒太多的线程）
    //多线程的数量取决于当前cpu的核心数

//线程池
    //线程池的优势
    //线程不会被销毁，是归线程
//fixed线程池
    //线程池里的线程是固定不变的，创建时主要是看机器当前的核心数量确定线程的数目的
//cached线程池
    //线程的数目是可变的，更具任务的数量会动态变化，根据设置值的阈值来决定线程数量

//线程同步
    //线程互斥 能不能在线程下执行，会不会出现竞态条件，临界区代码段，保证原子操作
                //代码在多线程的环境下运行，随着线程的带哦都顺序不同，得到不同的运行结果
                //如果正在多线程的环境下不存在竞态条件，那代码就是可重入的（反之不可重入）
    //互斥锁 mutex
                //一个线程只可以获取一个锁的条件，加锁后其他线程将被阻塞
    //CAS操作
                //无锁队列
                //无锁链表
                //无锁数组
    //原子类型 atomic

//线程通信（线程的调度是通过调度算法实现的和前后无关）
    //条件变量
        //notify通知线程从等待队列中转换为就绪状态
        //mutex + condition_variable
        //生产者消费者模型
            //1.先生产在消费
            //条件变量 wait(mutex) 1.改变了线程的状态   2.把互斥锁释放了
            //2.生产一个消费一个

    //信号量 semaphore
        //信号量c++20
        //看作资源计数没有限制的mutex
        //二原信号量和mutex一杨可以实现互斥操作
                //mutex和semaphore区别
                //mutex只能是那个线程获取锁，由那个线程释放锁  sem不同sem.wait()和sem.post可以在不同的线程
/*
 * semaphore sem(0);
 * sem.post();//资源计数+1
 */

//线程池的项目架构